<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADK Chat</title>
    <!-- Add marked.js for markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <!-- Add DOMPurify for sanitizing HTML -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
    <!-- Import Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Add Google Maps JavaScript API -->
    <script>
        (g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await (a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t[0].toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
            key: "YOUR_API_KEY",
            v: "alpha"
        });
    </script>
    <!-- Add Google Maps Web Components scripts -->
    <script type="module">
        // Import maps and place details components
        import { MapElement } from "https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places&v=beta&components=map";
        import { PlaceDetailsElement } from "https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places&v=beta&components=place_details";
        import { AdvancedMarkerElement } from "https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places&v=beta&components=advanced_marker";
        
        // This will run after the page loads
        window.addEventListener('DOMContentLoaded', () => {
            console.log('Map web components loaded');
            
            // Add error handling for components
            window.addEventListener('error', (e) => {
                if (e.message && e.message.includes('is not a function') && 
                    e.message.includes('placeDetailsElement')) {
                    console.warn('PlaceDetailsElement API mismatch. Using fallback approach.');
                }
            });
        });
    </script>
    <script>
        // Flag to track if API loaded successfully
        window.mapsApiLoaded = false;
        
        // This function will be called manually after the Maps API is loaded
        async function initMapsComponents() {
            try {
                console.log('Initializing Google Maps components');
                
                // Import the Places Library for PlaceDetailsElement
                const { PlaceDetailsElement } = await google.maps.importLibrary('places');
                
                console.log('Google Maps API and Places UI Kit loaded successfully');
                window.mapsApiLoaded = true;
                
                // Make sure we can access the old callback too
                if (typeof initGoogleMapsAPI === 'function') {
                    initGoogleMapsAPI();
                }
            } catch (error) {
                console.error('Error initializing Google Maps components:', error);
                handleMapsApiError();
            }
        }
        
        // Wait for the page to load, then initialize Maps components
        window.addEventListener('DOMContentLoaded', () => {
            // Add a small delay to ensure the Maps API has time to initialize
            setTimeout(initMapsComponents, 1000);
        });
        
        // This function is kept for backward compatibility with existing code
        function initGoogleMapsAPI() {
            console.log('Google Maps API loaded successfully (legacy callback)');
            window.mapsApiLoaded = true;
            
            // Check for any existing place details elements that need to be initialized
            const placeDetailsEl = document.getElementById('place-details-element');
            if (placeDetailsEl) {
                console.log('Found place details element, current place ID:', placeDetailsEl.getAttribute('place'));
                
                // If place ID is the placeholder, hide the element
                if (placeDetailsEl.getAttribute('place') === 'PLACE_ID') {
                    placeDetailsEl.style.display = 'none';
                }
            }
        }
        
        // Handle API loading errors
        function handleMapsApiError() {
            console.error('Google Maps API failed to load');
            // Create a div to show the error
            const errorDiv = document.createElement('div');
            errorDiv.style.background = '#ffebee';
            errorDiv.style.color = '#d32f2f';
            errorDiv.style.padding = '15px';
            errorDiv.style.borderRadius = '5px';
            errorDiv.style.margin = '10px 0';
            errorDiv.style.textAlign = 'center';
            errorDiv.innerHTML = '<h3>Maps API Error</h3><p>The Google Maps API failed to load. This might be due to an invalid API key. Check the console for more details.</p>';
            
            // Insert at top of body
            document.body.insertBefore(errorDiv, document.body.firstChild);
        }
    </script>
    <script>
        // Configure marked.js
        document.addEventListener('DOMContentLoaded', function() {
            // Test if marked is available
            if (typeof marked === 'undefined') {
                console.error('Marked.js not loaded properly');
                return;
            }
            
            // Configure marked
            marked.setOptions({
                breaks: true,
                gfm: true,
                headerIds: false,
                mangle: false,
                sanitize: false,
                smartLists: true,
                smartypants: true,
                xhtml: false
            });
            
            console.log('Marked.js configured successfully');
            
            // Test parsing
            const testMd = "**Bold** and *italic* with [link](https://example.com) and\n* List item 1\n* List item 2";
            console.log('Test markdown:', testMd);
            console.log('Parsed result:', marked.parse(testMd));
        });
    </script>
    <style>
        :root {
            --primary-color: #6c5ce7;
            --primary-dark: #5541d7;
            --primary-light: #a29bfe;
            --secondary-color: #00cec9;
            --accent-color: #fd79a8;
            --text-primary: #2d3436;
            --text-secondary: #636e72;
            --bg-color: #f9fafe;
            --card-bg: #ffffff;
            --user-msg-bg: #e4f0ff;
            --agent-msg-bg: #f5f7ff;
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 24px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            line-height: 1.6;
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        h1 {
            font-weight: 700;
            margin-bottom: 1.5rem;
            text-align: center;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: 2.5rem;
            letter-spacing: -0.5px;
        }

        #chat-container {
            flex: 1;
            background-color: var(--card-bg);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            overflow-y: auto;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            height: 60vh;
            scrollbar-width: thin;
            transition: var(--transition);
        }

        #chat-container::-webkit-scrollbar {
            width: 6px;
        }

        #chat-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        #chat-container::-webkit-scrollbar-thumb {
            background: var(--primary-light);
            border-radius: 10px;
        }

        .message {
            margin-bottom: 1rem;
            padding: 1rem 1.2rem;
            border-radius: var(--radius-sm);
            animation: fadeIn 0.3s ease-out;
            box-shadow: var(--shadow-sm);
            max-width: 80%;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message a {
            color: var(--primary-color);
            text-decoration: none;
            word-break: break-all;
            font-weight: 500;
            transition: var(--transition);
        }

        .message a:hover {
            color: var(--primary-dark);
            text-decoration: underline;
        }

        .user-message {
            background-color: var(--user-msg-bg);
            color: var(--text-primary);
            margin-left: auto;
            border-radius: var(--radius-sm) 0 var(--radius-sm) var(--radius-sm);
            border-right: 4px solid var(--primary-color);
            font-weight: 500;
        }

        .agent-message {
            background-color: var(--agent-msg-bg);
            color: var(--text-primary);
            margin-right: auto;
            border-radius: 0 var(--radius-sm) var(--radius-sm) var(--radius-sm);
            border-left: 4px solid var(--secondary-color);
        }

        .streaming:after {
            content: '...';
            display: inline-block;
            width: 1em;
            animation: streamingDots 1.5s infinite;
            color: var(--primary-color);
            font-weight: bold;
        }

        @keyframes streamingDots {
            0% { content: '.'; }
            33% { content: '..'; }
            66% { content: '...'; }
        }

        /* Enhanced streaming styles */
        .agent-message.streaming {
            background-color: rgba(245, 247, 255, 0.7);
            border-left: 4px dashed var(--secondary-color);
            position: relative;
        }
        
        .agent-message.streaming:before {
            content: "Processing...";
            position: absolute;
            top: 0;
            right: 0;
            font-size: 0.7rem;
            background-color: var(--secondary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 0 var(--radius-sm) 0 var(--radius-sm);
            font-weight: 500;
        }

        /* Style for intermediate function call messages */
        .agent-message.function-call {
            background-color: rgba(240, 240, 250, 0.8);
            border-left: 4px dotted var(--primary-light);
        }
        
        .agent-message.function-call:before {
            content: "🔍";
            margin-right: 6px;
        }

        .system-message {
            color: var(--text-secondary);
            font-style: italic;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-sm);
            margin: 0.8rem auto;
            max-width: 90%;
            font-size: 0.9rem;
            box-shadow: var(--shadow-sm);
            border-left: 2px solid var(--accent-color);
            border-right: 2px solid var(--accent-color);
        }

        .debugging {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            background-color: rgba(0, 0, 0, 0.03);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--radius-sm);
            padding: 0.5rem;
            margin-top: 0.5rem;
            overflow-x: auto;
            max-height: 150px;
            display: none;
        }

        #input-container {
            display: flex;
            gap: 0.8rem;
            position: relative;
            margin-bottom: 1rem;
        }

        #message-input {
            flex-grow: 1;
            padding: 1rem 1.2rem;
            border: none;
            border-radius: var(--radius-lg);
            background-color: var(--card-bg);
            box-shadow: var(--shadow-sm);
            font-family: 'Poppins', sans-serif;
            font-size: 1rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        #message-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--primary-light);
        }

        button {
            padding: 0.8rem 1.5rem;
            background: linear-gradient(45deg, var(--primary-color), var(--primary-dark));
            color: white;
            border: none;
            border-radius: var(--radius-lg);
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: linear-gradient(45deg, #b2b2b2, #d3d3d3);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #session-container {
            margin-bottom: 2rem;
            text-align: center;
        }

        .hidden {
            display: none;
        }

        #settings-container {
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: flex-end;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-secondary);
            user-select: none;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin: 0 0.5rem;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        #location-status {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-right: auto;
            background-color: var(--card-bg);
            padding: 0.5rem 0.8rem;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-sm);
        }

        .location-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            transition: var(--transition);
        }

        .location-on {
            background-color: #00b894;
            box-shadow: 0 0 8px rgba(0, 184, 148, 0.5);
        }

        .location-off {
            background-color: #ff7675;
            box-shadow: 0 0 8px rgba(255, 118, 117, 0.5);
        }

        .location-pending {
            background-color: #fdcb6e;
            box-shadow: 0 0 8px rgba(253, 203, 110, 0.5);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(0.95); opacity: 0.7; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(0.95); opacity: 0.7; }
        }

        #create-session-btn {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: var(--radius-md);
            margin: 2rem auto;
            display: block;
        }

        .message ul, .message ol {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
        }

        .message li {
            margin-bottom: 0.3rem;
        }

        .message p {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        #request-location-btn {
            font-size: 0.8rem;
            padding: 0.4rem 0.8rem;
            margin-left: 0.5rem;
        }

        #chat-interface {
            display: flex;
            flex-direction: column;
            height: 85vh;
        }

        /* Dark mode support - add a toggle button to your HTML */
        .dark-mode {
            --bg-color: #1a1c2a;
            --card-bg: #282a36;
            --text-primary: #f8f8f2;
            --text-secondary: #d3d3d3;
            --user-msg-bg: #483d8b;
            --agent-msg-bg: #2c2c44;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            .message {
                max-width: 90%;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            #settings-container {
                flex-direction: column;
                align-items: flex-start;
            }
            
            #location-status {
                margin-right: 0;
                margin-bottom: 0.5rem;
                width: 100%;
            }
        }
        
        /* Map modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.3s;
        }
        
        .modal.show {
            display: block;
        }
        
        .modal-content {
            background-color: var(--card-bg);
            margin: 5% auto;
            border-radius: var(--radius-md);
            width: 80%;
            max-width: 900px;
            box-shadow: var(--shadow-md);
            animation: slideIn 0.4s;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
            color: var(--primary-color);
        }
        
        .close-modal {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition);
        }
        
        .close-modal:hover {
            color: var(--primary-color);
        }
        
        .modal-body {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        #place-info {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        #map-container {
            width: 100%;
            height: 400px;
            border-radius: var(--radius-sm);
            overflow: hidden;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        #place-info {
            margin-bottom: 1rem;
        }
        
        #place-address {
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        #place-rating {
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }
        
        #place-website {
            margin-bottom: 0.5rem;
        }
        
        #place-website a {
            color: var(--primary-color);
            text-decoration: none;
        }
        
        #place-website a:hover {
            text-decoration: underline;
        }
        
        #place-phone {
            color: var(--text-secondary);
        }
        
        .hidden {
            display: none;
        }

        /* Styles for Place Details Element */
        gmp-place-details {
            margin-top: 15px;
            padding: 15px;
            border-radius: var(--radius-sm);
            background-color: rgba(248, 248, 255, 0.6);
            box-shadow: var(--shadow-sm);
            font-family: 'Poppins', sans-serif;
            max-width: 100%;
            overflow: hidden;
        }
        
        /* Dark mode support for place details */
        .dark-mode gmp-place-details {
            background-color: rgba(40, 42, 54, 0.8);
            color: var(--text-primary);
        }
        
        /* Google Maps UI Kit Styles */
        gmp-map {
            width: 100%;
            height: 400px;
            border-radius: var(--radius-sm);
            overflow: hidden;
        }
        
        .details-container {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--card-bg);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
        }
        
        gmp-place-details {
            width: 100%;
            padding: 15px 0;
            font-family: 'Poppins', sans-serif;
        }
        
        @media (max-width: 768px) {
            .details-container {
                padding: 10px;
            }
            
            gmp-place-details {
                padding: 10px 0;
            }
        }
        
        /* Make place details look more like the Google Maps style */
        ::part(name) {
            font-size: 1.4em;
            font-weight: 500;
            color: #202124;
        }
        
        ::part(address) {
            color: #5f6368;
            margin-bottom: 8px;
        }
        
        ::part(rating) {
            color: #e7711b;
            font-weight: 500;
        }
        
        ::part(link) {
            color: #1a73e8;
            text-decoration: none;
        }
        
        ::part(link):hover {
            text-decoration: underline;
        }
        
        /* Dark mode support */
        .dark-mode gmp-place-details {
            background-color: #2d2e32;
            color: #e8eaed;
        }
        
        .dark-mode ::part(name) {
            color: #e8eaed;
        }
        
        .dark-mode ::part(address) {
            color: #c6c8ca;
        }

        /* Styles for PlaceDetailsElement */
        .widget-container {
            height: 500px;
            width: 457px; 
            overflow-y: auto;
            overflow-x: hidden;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: var(--radius-sm);
            padding: 0;
            box-shadow: var(--shadow-md);
        }
        
        gmp-map {
            height: 500px;
            width: 100%;
            border-radius: var(--radius-sm);
        }
        
        gmp-place-details {
            background-color: #fff;
            border-radius: 8px;
            padding: 0;
            margin: 0;
            font-family: 'Poppins', sans-serif;
            width: 100%;
        }
        
        /* Make the modal bigger to fit all the place details */
        .modal-content {
            width: 90%;
            max-width: 1000px;
            height: 90vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
        }
        
        .modal-body {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        gmp-advanced-marker {
            display: none;
        }
        
        @media (max-width: 768px) {
            .widget-container {
                width: 100%;
                max-width: 100%;
                height: 450px;
            }
            
            gmp-map {
                height: 350px;
            }
            
            .modal-content {
                width: 95%;
                height: 95vh;
            }
        }
        
        /* Dark mode support */
        .dark-mode .widget-container {
            background-color: rgba(40, 42, 54, 0.9);
        }
        
        .dark-mode gmp-place-details {
            background-color: #2d2e32;
            color: #e8eaed;
        }
    </style>
    
    <!-- Additional styles for the new session button -->
    <style>
        .small-button {
            font-size: 0.8rem;
            padding: 0.4rem 0.8rem;
            border-radius: var(--radius-sm);
            background: linear-gradient(45deg, var(--secondary-color), var(--primary-light));
            margin-left: 0.5rem;
        }
    </style>
</head>
<body>
    <h1>Taipei travel guide built by Google ADK</h1>
    <div id="session-container">
        <button onclick="createSession()" id="create-session-btn">Create Session</button>
    </div>
    <div id="chat-interface" class="hidden">
        <div id="settings-container">
            <div id="location-status">
                <span class="location-indicator location-pending"></span>
                <span id="location-text">Requesting location...</span>
                <button id="request-location-btn" class="hidden" onclick="requestLocation()">Enable Location</button>
            </div>
            <label class="toggle-label">
                <span>Use Streaming</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="streaming-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <label class="toggle-label">
                <span>Show Debug Info</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="debug-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <button onclick="createNewSession()" id="new-session-btn" class="small-button">New Session</button>
        </div>
        <div id="chat-container"></div>
        <div id="input-container">
            <input type="text" id="message-input" placeholder="Type your message...">
            <button onclick="sendMessage()" id="send-button">Send</button>
        </div>
    </div>

    <script>
        // Use our own server as the API URL
        const API_URL = window.location.origin;
        const APP_NAME = 'deep_tAIpei';
        const USER_ID = 'u_123';
        let SESSION_ID = generateSessionId();
        let sessionCreated = false;
        let activeResponseId = null; // Track the current response message for streaming

        // Generate a random session ID
        function generateSessionId() {
            // Generate a random string with timestamp to ensure uniqueness
            const timestamp = new Date().getTime();
            const random = Math.random().toString(36).substring(2, 15);
            return `s_${timestamp}_${random}`;
        }

        // Save session ID to local storage
        function saveSessionId(sessionId) {
            localStorage.setItem('taipeiGuideSessionId', sessionId);
        }

        // Load session ID from local storage
        function loadSessionId() {
            const savedId = localStorage.getItem('taipeiGuideSessionId');
            return savedId || generateSessionId();
        }

        // Initialize from local storage if available
        document.addEventListener('DOMContentLoaded', function() {
            SESSION_ID = loadSessionId();
            
            // Show current session ID in a debug message if debug is enabled
            const debugToggle = document.getElementById('debug-toggle');
            if (debugToggle && debugToggle.checked) {
                console.log(`Current session ID: ${SESSION_ID}`);
            }
        });

        // Create a brand new session (can be called anytime)
        function createNewSession() {
            // Generate a new session ID
            SESSION_ID = generateSessionId();
            saveSessionId(SESSION_ID);
            
            // Reset the UI
            const chatContainer = document.getElementById('chat-container');
            if (chatContainer) {
                chatContainer.innerHTML = '';
            }
            
            // Call createSession to establish a new session
            sessionCreated = false;
            createSession();
        }

        // Location tracking
        let userLocation = null;
        let locationStatus = 'pending'; // 'pending', 'granted', 'denied', 'unsupported'

        function updateLocationStatus(status, message) {
            const indicator = document.querySelector('.location-indicator');
            const statusText = document.getElementById('location-text');
            const requestBtn = document.getElementById('request-location-btn');
            
            locationStatus = status;
            
            // Update indicator
            indicator.className = 'location-indicator';
            indicator.classList.add(`location-${status === 'granted' ? 'on' : (status === 'pending' ? 'pending' : 'off')}`);
            
            // Update text
            statusText.textContent = message;
            
            // Show/hide request button
            if (status === 'denied') {
                requestBtn.classList.remove('hidden');
            } else {
                requestBtn.classList.add('hidden');
            }
        }

        function requestLocation() {
            updateLocationStatus('pending', 'Requesting location...');
            
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    handleLocationSuccess,
                    handleLocationError
                );
            } else {
                updateLocationStatus('unsupported', 'Geolocation not supported by browser');
            }
        }

        function handleLocationSuccess(position) {
            userLocation = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: new Date().toISOString()
            };
            
            updateLocationStatus('granted', `Location available (${userLocation.lat.toFixed(2)}, ${userLocation.lng.toFixed(2)})`);
            
            // Send location to server
            storeLocation();
        }

        function handleLocationError(error) {
            console.error('Geolocation error:', error);
            
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    updateLocationStatus('denied', 'Location permission denied');
                    break;
                case error.POSITION_UNAVAILABLE:
                    updateLocationStatus('denied', 'Location information unavailable');
                    break;
                case error.TIMEOUT:
                    updateLocationStatus('denied', 'Location request timed out');
                    break;
                default:
                    updateLocationStatus('denied', 'Unknown location error');
            }
        }

        async function storeLocation() {
            if (!userLocation) return;
            
            try {
                const response = await fetch(`${API_URL}/proxy/store_location`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(userLocation)
                });
                
                if (!response.ok) {
                    console.error('Failed to store location on server');
                }
            } catch (error) {
                console.error('Error storing location:', error);
            }
        }

        async function createSession() {
            const createSessionBtn = document.getElementById('create-session-btn');
            if (!createSessionBtn) {
                console.error('Create session button not found');
                return;
            }

            try {
                createSessionBtn.disabled = true;
                addMessage('Creating new session...', 'system');
                
                // Show the current session ID in debug view
                addMessage(`Session ID: ${SESSION_ID}`, 'system');
                
                const response = await fetch(`${API_URL}/proxy/session/${APP_NAME}/${USER_ID}/${SESSION_ID}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        state: {
                            key1: "value1",
                            key2: 42
                        }
                    })
                });
                
                // Save successful session ID to local storage
                saveSessionId(SESSION_ID);
                
                const responseData = await response.json();
                console.log('Session creation response:', responseData);

                // Check if it's a "Session already exists" error, which we'll treat as success
                if (response.status === 400 && responseData.detail && responseData.detail.includes("Session already exists")) {
                    console.log("Session already exists, continuing as normal");
                    
                    // Show chat interface and hide create session button
                    document.getElementById('chat-interface').classList.remove('hidden');
                    document.getElementById('session-container').classList.add('hidden');
                    sessionCreated = true;
                    addMessage('Using existing session. You can now start chatting.', 'system');
                    
                    // Add greeting message from the agent (for existing sessions too)
                    addMessage('👋 Welcome back to the Taipei Travel Guide! I can help you with:\n\n- Finding places of interest in Taipei\n- Providing weather and local time information\n- Suggesting restaurants, attractions, and activities\n- Answering questions about Taipei\'s culture and transportation\n\nJust type your questions or requests, and I\'ll assist you!', 'agent');
                    
                    // Request location as soon as session is created/connected
                    requestLocation();
                    return;
                }

                if (!response.ok) {
                    throw new Error(`Failed to create session: ${response.status}`);
                }
                
                // Show chat interface and hide create session button
                document.getElementById('chat-interface').classList.remove('hidden');
                document.getElementById('session-container').classList.add('hidden');
                sessionCreated = true;
                addMessage('Session created successfully! You can now start chatting.', 'system');
                
                // Add greeting message from the agent
                addMessage('👋 Welcome to the Taipei Travel Guide! I can help you with:\n\n- Finding places of interest in Taipei\n- Providing weather and local time information\n- Suggesting restaurants, attractions, and activities\n- Answering questions about Taipei\'s culture and transportation\n\nJust type your questions or requests, and I\'ll assist you!', 'agent');
                
                // Request location as soon as session is created
                requestLocation();
            } catch (error) {
                console.error('Error creating session:', error);
                addMessage(`Error: ${error.message}. Make sure you started the ADK server in the correct directory.`, 'system');
                if (createSessionBtn) {
                    createSessionBtn.disabled = false;
                }
            }
        }

        function addMessage(text, type, responseId = null) {
            const chatContainer = document.getElementById('chat-container');
            
            // Debug the input text
            if (type === 'agent') {
                console.log('Agent message to parse:', text);
            }
            
            // If this is a streaming update and we have a response ID, find the existing message
            if (type === 'agent' && responseId && responseId === activeResponseId) {
                const existingMsg = document.getElementById(`response-${responseId}`);
                if (existingMsg) {
                    // Only parse markdown for agent messages
                    existingMsg.innerHTML = type === 'user' ? text : processText(text);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    return existingMsg;
                }
            }
            
            // Otherwise create a new message
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            // Only parse markdown for agent messages
            messageDiv.innerHTML = type === 'user' ? text : processText(text);
            
            // If this is an agent response with an ID, set it
            if (type === 'agent' && responseId) {
                messageDiv.id = `response-${responseId}`;
                activeResponseId = responseId;
            }
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            return messageDiv;
        }
        
        // Helper function to process text with markdown and fix URLs
        function processText(text) {
            if (!text) return '';
            
            console.log('Processing text with markdown:', text);
            
            try {
                // Pre-process the text to ensure proper markdown format
                // Make sure numbered lists have a space after the period
                let processedText = text.replace(/^(\d+)\.(\S)/gm, '$1. $2');
                
                // Make sure bullet points have a space after them
                processedText = processedText.replace(/^[*-](\S)/gm, '* $1');
                
                console.log('Pre-processed text:', processedText);
                
                // Process with marked library
                const markedOutput = marked.parse(processedText);
                console.log('Marked output:', markedOutput);
                
                // Sanitize the output with DOMPurify to prevent XSS
                const sanitized = typeof DOMPurify !== 'undefined' ? 
                    DOMPurify.sanitize(markedOutput) : markedOutput;
                
                return sanitized;
            } catch (e) {
                console.error("Error parsing markdown:", e);
                // Fallback to basic processing if marked fails
                return simpleMarkdown(text);
            }
        }
        
        // Simple markdown processor as fallback
        function simpleMarkdown(text) {
            if (!text) return '';
            
            console.log('Using simple markdown processor');
            
            // Convert line breaks to <br>
            let html = text.replace(/\n/g, '<br>');
            
            // Bold text
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Italic text
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Numbered lists
            if (html.match(/^\d+\.\s+.+/gm)) {
                let lines = html.split('<br>');
                let inList = false;
                
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].match(/^\d+\.\s+.+/)) {
                        if (!inList) {
                            lines[i] = '<ol><li>' + lines[i].replace(/^\d+\.\s+/, '') + '</li>';
                            inList = true;
                        } else {
                            lines[i] = '<li>' + lines[i].replace(/^\d+\.\s+/, '') + '</li>';
                        }
                        
                        // If next line is not a list item or this is the last line
                        if (i === lines.length - 1 || !lines[i+1].match(/^\d+\.\s+.+/)) {
                            lines[i] += '</ol>';
                            inList = false;
                        }
                    }
                }
                
                html = lines.join('<br>');
            }
            
            // Bullet lists
            if (html.match(/^[\*-]\s+.+/gm)) {
                let lines = html.split('<br>');
                let inList = false;
                
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].match(/^[\*-]\s+.+/)) {
                        if (!inList) {
                            lines[i] = '<ul><li>' + lines[i].replace(/^[\*-]\s+/, '') + '</li>';
                            inList = true;
                        } else {
                            lines[i] = '<li>' + lines[i].replace(/^[\*-]\s+/, '') + '</li>';
                        }
                        
                        // If next line is not a list item or this is the last line
                        if (i === lines.length - 1 || !lines[i+1].match(/^[\*-]\s+.+/)) {
                            lines[i] += '</ul>';
                            inList = false;
                        }
                    }
                }
                
                html = lines.join('<br>');
            }
            
            // URLs
            html = html.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
            
            return html;
        }

        function addDebugInfo(messageElement, data) {
            // Check if we should show debug info
            const showDebug = document.getElementById('debug-toggle').checked;
            
            // Create debug element
            const debugDiv = document.createElement('div');
            debugDiv.className = 'debugging';
            debugDiv.style.display = showDebug ? 'block' : 'none';
            
            // Format the debug content
            let debugContent;
            try {
                if (typeof data === 'string') {
                    debugContent = data;
                } else {
                    debugContent = JSON.stringify(data, null, 2);
                }
            } catch (e) {
                debugContent = String(data);
            }
            
            debugDiv.textContent = debugContent;
            messageElement.appendChild(debugDiv);
            
            // Update toggle listener
            document.getElementById('debug-toggle').addEventListener('change', (e) => {
                const debugElements = document.querySelectorAll('.debugging');
                debugElements.forEach(el => {
                    el.style.display = e.target.checked ? 'block' : 'none';
                });
            });
        }

        async function sendMessage() {
            if (!sessionCreated) {
                addMessage('Please create a session first!', 'system');
                return;
            }

            const input = document.getElementById('message-input');
            const sendButton = document.getElementById('send-button');
            const message = input.value.trim();
            const useStreaming = document.getElementById('streaming-toggle').checked;
            
            if (!message) return;
            
            // Add user message to chat
            addMessage(message, 'user');
            input.value = '';
            sendButton.disabled = true;

            // Reset active response tracking
            activeResponseId = null;
            
            try {
                if (useStreaming) {
                    // Step 1: Prepare the SSE connection by sending a POST request
                    const prepareResponse = await fetch(`${API_URL}/proxy/prepare_sse`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            app_name: APP_NAME,
                            user_id: USER_ID,
                            session_id: SESSION_ID,
                            new_message: {
                                role: "user",
                                parts: [{
                                    text: message
                                }]
                            }
                        })
                    });
                    
                    if (!prepareResponse.ok) {
                        throw new Error(`Failed to prepare streaming: ${prepareResponse.status}`);
                    }
                    
                    const prepareData = await prepareResponse.json();
                    const requestId = prepareData.request_id;
                    
                    if (!requestId) {
                        throw new Error("No request ID received for streaming");
                    }
                    
                    // Step 2: Connect to the SSE endpoint with the request ID
                    const eventSource = new EventSource(`${API_URL}/proxy/sse_connect/${requestId}`);
                    
                    let messageElement = null;
                    let finalText = '';
                    
                    eventSource.onmessage = async (event) => {
                        // Skip empty events
                        if (!event.data.trim()) return;
                        
                        // Get chat container here to ensure it's in scope
                        const chatContainer = document.getElementById('chat-container');
                        if (!chatContainer) {
                            console.error('Chat container not found');
                            return;
                        }
                        
                        try {
                            // Process each event
                            console.log("SSE Event:", event);
                            
                            const data = JSON.parse(event.data);
                            
                            // Process tool calls, function responses, and text responses
                            if (data.content && data.content.parts) {
                                for (const part of data.content.parts) {
                                    // Function call (showing what the agent is doing)
                                    if (part.functionCall) {
                                        const functionName = part.functionCall.name;
                                        const args = part.functionCall.args;
                                        finalText = `Fetching data using ${functionName}...`;
                                        
                                        if (!messageElement) {
                                            messageElement = addMessage(finalText, 'agent', data.id);
                                            messageElement.classList.add('function-call');
                                            addDebugInfo(messageElement, data);
                                        } else {
                                            messageElement.textContent = finalText;
                                            messageElement.classList.add('function-call');
                                            addDebugInfo(messageElement, data);
                                        }
                                    }
                                    
                                    // Function response
                                    if (part.functionResponse) {
                                        const functionName = part.functionResponse.name;
                                        const response = part.functionResponse.response;
                                        
                                        // Check if this is a place details response
                                        if (functionName === 'show_place_details') {
                                            // Use a self-executing async function to use await
                                            (async () => {
                                                if (await handlePlaceDetailsResponse(response)) {
                                                    // If handled, update the message to indicate a map is being shown
                                                    finalText = `Showing ${response.name || 'place'} on a map`;
                                                    
                                                    if (!messageElement) {
                                                        messageElement = addMessage(finalText, 'agent', data.id);
                                                    } else {
                                                        messageElement.innerHTML = processText(finalText);
                                                    }
                                                }
                                            })();
                                            continue;
                                        }
                                        
                                        if (response.report) {
                                            finalText = `Got data from ${functionName}: ${response.report}`;
                                        } else {
                                            finalText = `Function ${functionName} completed.`;
                                        }
                                        
                                        if (!messageElement) {
                                            messageElement = addMessage(finalText, 'agent', data.id);
                                            addDebugInfo(messageElement, data);
                                        } else {
                                            messageElement.textContent = finalText;
                                            addDebugInfo(messageElement, data);
                                        }
                                    }
                                    
                                    // Text response (final output)
                                    if (part.text) {
                                        // Check if this is a complete message
                                        const isCompleteMessage = 
                                            part.text.length > 50 || // Longer messages are likely complete
                                            part.text.includes("Function") && part.text.includes("completed") ||
                                            part.text.trim().startsWith("Okay,") ||
                                            part.text.trim().startsWith("Here are") ||
                                            part.text.trim().startsWith("Sure,");
                                            
                                        if (isCompleteMessage) {
                                            // This is a complete message - replace existing content
                                            finalText = part.text;
                                        } else if (!finalText.includes(part.text)) {
                                            // This is a fragment - append if not already included
                                            finalText += part.text;
                                        }
                                        
                                        if (!messageElement) {
                                            // Create the initial message element without markdown
                                            messageElement = document.createElement('div');
                                            messageElement.className = `message agent-message streaming`;
                                            messageElement.textContent = finalText;
                                            
                                            if (data.id) {
                                                messageElement.id = `response-${data.id}`;
                                                activeResponseId = data.id;
                                            }
                                            
                                            chatContainer.appendChild(messageElement);
                                            addDebugInfo(messageElement, data);
                                        } else {
                                            // Update the text content first
                                            messageElement.textContent = finalText;
                                            
                                            // Only apply markdown on the final message or after a delay
                                            clearTimeout(messageElement.pendingMarkdown);
                                            
                                            if (isCompleteMessage) {
                                                // Apply markdown immediately for complete messages
                                                messageElement.classList.remove('streaming');
                                                messageElement.classList.remove('function-call');
                                                messageElement.innerHTML = processText(finalText);
                                                console.log('Applied markdown to complete message');
                                            } else {
                                                // For fragments, wait a bit to collect more text
                                                messageElement.pendingMarkdown = setTimeout(() => {
                                                    messageElement.classList.remove('streaming');
                                                    messageElement.classList.remove('function-call');
                                                    messageElement.innerHTML = processText(finalText);
                                                    console.log('Applied markdown to accumulated text');
                                                }, 500);
                                            }
                                            
                                            addDebugInfo(messageElement, data);
                                        }
                                        
                                        chatContainer.scrollTop = chatContainer.scrollHeight;
                                    }
                                }
                            }
                        } catch (e) {
                            console.error("Error processing SSE event:", e);
                            // Try to show the raw event data if parsing fails
                            if (!messageElement) {
                                messageElement = addMessage(`Processing response...`, 'agent');
                                addDebugInfo(messageElement, event.data);
                            }
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        console.error("SSE Error:", error);
                        eventSource.close();
                        
                        // Show error if no messages have been displayed
                        if (!messageElement) {
                            addMessage("Error getting response from agent", 'system');
                        } else {
                            // Make sure we remove the streaming indicator if there's an error
                            messageElement.classList.remove('streaming');
                        }
                        
                        sendButton.disabled = false;
                    };
                    
                    // Close the event source after a minute (should be done much earlier)
                    setTimeout(() => {
                        if (eventSource.readyState !== 2) { // Not closed
                            eventSource.close();
                            sendButton.disabled = false;
                        }
                    }, 60000);
                } else {
                    // Use regular endpoint for non-streaming
                    const response = await fetch(`${API_URL}/proxy/run`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            app_name: APP_NAME,
                            user_id: USER_ID,
                            session_id: SESSION_ID,
                            new_message: {
                                role: "user",
                                parts: [{
                                    text: message
                                }]
                            }
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API error: ${response.status} ${errorText}`);
                    }

                    const data = await response.json();
                    console.log("API Response:", data);
                    
                    if (data && data.length > 0) {
                        // Looking for model responses by checking each event
                        for (const event of data) {
                            // Check if this is a model's text response
                            if (event.content && event.content.parts) {
                                for (const part of event.content.parts) {
                                    // Check for place details response first
                                    if (part.functionResponse && 
                                        part.functionResponse.name === 'show_place_details') {
                                        const response = part.functionResponse.response;
                                        
                                        // Use async/await with an IIFE
                                        (async () => {
                                            if (await handlePlaceDetailsResponse(response)) {
                                                // Add a message indicating place is showing on map
                                                const msgElement = addMessage(
                                                    `Showing ${response.name || 'place'} on a map`, 
                                                    'agent'
                                                );
                                                addDebugInfo(msgElement, event);
                                            }
                                        })();
                                        continue;
                                    }
                                    
                                    // Regular text response
                                    if (part.text) {
                                        const msgElement = addMessage(part.text, 'agent');
                                        addDebugInfo(msgElement, event);
                                        // Break after finding the first text response
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        addMessage("No response from agent", 'system');
                    }
                    
                    sendButton.disabled = false;
                }
            } catch (error) {
                console.error('Error sending message:', error);
                addMessage(`Error: ${error.message}`, 'system');
                sendButton.disabled = false;
            }
        }

        // Allow sending message with Enter key
        document.getElementById('message-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !document.getElementById('send-button').disabled) {
                sendMessage();
            }
        });

        // Toggle event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize any toggles that need immediate setup
            document.getElementById('debug-toggle').addEventListener('change', (e) => {
                const debugElements = document.querySelectorAll('.debugging');
                debugElements.forEach(el => {
                    el.style.display = e.target.checked ? 'block' : 'none';
                });
            });
            
            // Initialize map modal events
            initMapModal();
        });
        
        // Map and place details handling
        let map = null;
        let placeMarker = null;
        let placesService = null;
        
        // Global variables for map elements
        let placeModal = {
            map: null,
            marker: null,
            placeDetails: null,
            innerMap: null
        };
        
        // Function to initialize the map modal
        async function initMapModal() {
            console.log('Initializing map modal with Places UI Kit');
            
            try {
                // Request needed libraries
                const { Map } = await google.maps.importLibrary("maps");
                const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
                const { Place, PlaceDetailsElement } = await google.maps.importLibrary("places");
                
                // Get elements
                placeModal.map = document.getElementById('gmp-map');
                placeModal.placeDetails = document.getElementById('place-details-element');
                placeModal.marker = document.getElementById('place-marker');
                
                if (!placeModal.map) {
                    console.error('Map element not found');
                    return;
                }
                
                // Wait for the map to be defined
                if (!placeModal.map.innerMap) {
                    // Add an event listener to wait for the map to be ready
                    placeModal.map.addEventListener('ready', setupMapElements);
                } else {
                    setupMapElements();
                }
            } catch (error) {
                console.error('Error initializing map modal:', error);
            }
        }
        
        function setupMapElements() {
            console.log('Setting up map elements');
            
            // Get the inner map
            placeModal.innerMap = placeModal.map.innerMap;
            
            // Hide the map type control
            if (placeModal.innerMap) {
                placeModal.innerMap.setOptions({ mapTypeControl: false });
                
                // Add a click event listener to the map
                placeModal.innerMap.addListener('click', async (event) => {
                    try {
                        if (event.placeId) {
                            // Fire when the user clicks a POI
                            await placeModal.placeDetails.configureFromPlace({ id: event.placeId });
                        } else {
                            // Fire when the user clicks the map (not on a POI)
                            await placeModal.placeDetails.configureFromLocation(event.latLng);
                        }
                        
                        // Update marker position
                        if (placeModal.marker && placeModal.placeDetails.place && placeModal.placeDetails.place.location) {
                            placeModal.marker.position = placeModal.placeDetails.place.location;
                            placeModal.marker.style.display = 'block';
                        }
                    } catch (e) {
                        console.error('Error handling map click:', e);
                    }
                });
            }
        }
        
        // Function to display place details with the new approach
        async function displayPlaceWithUIKit(placeId, latLng) {
            console.log('Displaying place with UI Kit:', placeId || latLng);
            
            // Show modal
            showMapModal();
            
            try {
                const { Place } = await google.maps.importLibrary("places");
                
                // Initialize map elements if not already done
                if (!placeModal.innerMap) {
                    await initMapModal();
                }
                
                // Wait a bit for components to initialize
                setTimeout(async () => {
                    try {
                        if (placeId) {
                            // Create a Place object
                            const place = new Place({
                                id: placeId,
                                requestedLanguage: "en"
                            });
                            
                            // Configure from place
                            await placeModal.placeDetails.configureFromPlace(place);
                            
                            // Fetch additional fields if available
                            try {
                                if (place.fetchFields) {
                                    await place.fetchFields({
                                        fields: [
                                            "businessStatus",
                                            "formattedAddress", 
                                            "location", 
                                            "displayName",
                                            "photos", 
                                            "googleMapsUri", 
                                            "websiteUri", 
                                            "regularOpeningHours",
                                            "utcOffsetMinutes",
                                            "priceLevel",
                                            "rating",
                                            "userRatingCount",
                                            "serviceOptions",
                                            "shortFormattedAddress",
                                            "reviews",
                                            "takeout",
                                            "delivery",
                                            "dineIn",
                                            "servesBreakfast",
                                            "servesLunch",
                                            "servesDinner",
                                            "servesBrunch",
                                            "outdoorSeating",
                                            "restaurantSpecialties",
                                            "menuForChildren",
                                            "primaryType",
                                            "paymentOptions",
                                            "parkingOptions"
                                        ]
                                    });
                                    
                                    console.log("Successfully fetched additional fields for place:", place);
                                }
                            } catch (error) {
                                console.warn("Could not fetch additional fields:", error);
                            }
                            
                            // Update map and marker
                            if (placeModal.placeDetails.place && placeModal.placeDetails.place.location) {
                                // Center map and update marker
                                placeModal.innerMap.panTo(placeModal.placeDetails.place.location);
                                placeModal.innerMap.setZoom(16);
                                
                                // Update marker
                                placeModal.marker.position = placeModal.placeDetails.place.location;
                                placeModal.marker.style.display = 'block';
                            }
                        } else if (latLng) {
                            // Configure from location
                            await placeModal.placeDetails.configureFromLocation(latLng);
                            
                            // Center map and update marker
                            placeModal.innerMap.panTo(latLng);
                            placeModal.innerMap.setZoom(16);
                            
                            // Update marker
                            placeModal.marker.position = latLng;
                            placeModal.marker.style.display = 'block';
                        }
                    } catch (e) {
                        console.error('Error configuring place details:', e);
                        // Fall back to legacy approach
                        document.getElementById('place-info').classList.remove('hidden');
                    }
                }, 500);
            } catch (error) {
                console.error('Error displaying place with UI Kit:', error);
                // Fall back to legacy approach
                if (placeId) {
                    await initializeMap(placeId, null, null);
                } else if (latLng) {
                    await initializeMap(null, latLng.lat, latLng.lng);
                }
            }
        }
        
        function initModalControls() {
            // Set up modal close button
            const closeButton = document.querySelector('.close-modal');
            if (closeButton) {
                closeButton.addEventListener('click', closeMapModal);
            }
            
            // Close modal when clicking outside
            window.addEventListener('click', (e) => {
                const modal = document.getElementById('map-modal');
                if (e.target === modal) {
                    closeMapModal();
                }
            });
            
            // Close with escape key
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeMapModal();
                }
            });
        }

        function showMapModal() {
            const modal = document.getElementById('map-modal');
            modal.classList.remove('hidden');
            modal.classList.add('show');
        }
        
        function closeMapModal() {
            const modal = document.getElementById('map-modal');
            modal.classList.remove('show');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }
        
        // Initialize modal controls when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initModalControls();
        });

        // Function to handle place details response from the AI
        async function handlePlaceDetailsResponse(response) {
            console.log('Received place details response:', response);
            
            if (!response) {
                console.error('Empty response received in handlePlaceDetailsResponse');
                return false;
            }
            
            if (response.status !== 'success') {
                console.error('Place details response status:', response.status);
                return false;
            }
            
            if (!response.ui_action) {
                console.error('Missing ui_action flag in place details response');
                return false;
            }
            
            if (response.status === 'success' && 
                response.ui_action === 'show_map') {
                
                // Display place details on map
                try {
                    if (response.place_id) {
                        // Use the new UI Kit approach
                        await displayPlaceWithUIKit(response.place_id, null);
                    } else if (response.location) {
                        // Use coordinates
                        await displayPlaceWithUIKit(null, response.location);
                    } else {
                        throw new Error('No place ID or location provided');
                    }
                    return true;
                } catch (e) {
                    console.error('Error displaying place details:', e);
                    return false;
                }
            }
            
            console.log('Place details response did not meet criteria for map display');
            return false;
        }
    </script>

    <!-- Add map modal container -->
    <div id="map-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="place-name">Place Details</h2>
                <span class="close-modal">&times;</span>
            </div>
            <div class="modal-body">
                <!-- Map with place details UI Kit implementation -->
                <gmp-map id="gmp-map" center="25.033, 121.565" zoom="16" map-id="DEMO_MAP_ID">
                    <div class="widget-container" slot="control-inline-start-block-start">
                        <gmp-place-details id="place-details-element" 
                            size="x-large"
                            place-mode="info"
                            show-attribution="true"
                            show-photos="true"
                            show-hours="true"
                            show-reviews="true"
                            show-contact="true"
                            show-service-options="true"
                            show-about="true"
                            show-menu="true"
                            show-directions="true">
                        </gmp-place-details>
                    </div>
                    <gmp-advanced-marker id="place-marker"></gmp-advanced-marker>
                </gmp-map>
                
                <!-- Legacy fallback info -->
                <div id="place-info" class="hidden">
                    <div id="place-address"></div>
                    <div id="place-rating"></div>
                    <div id="place-website"></div>
                    <div id="place-phone"></div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>