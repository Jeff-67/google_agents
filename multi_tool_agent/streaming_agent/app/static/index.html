<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADK Chat</title>
    <!-- Add marked.js for markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <!-- Add DOMPurify for sanitizing HTML -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
    <!-- Import Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Add Google Maps JavaScript API -->
    <script>
        // Flag to track if API loaded successfully
        window.mapsApiLoaded = false;
        
        // This function will be called when the API is loaded
        function initGoogleMapsAPI() {
            console.log('Google Maps API loaded successfully');
            window.mapsApiLoaded = true;
        }
        
        // Handle API loading errors
        function handleMapsApiError() {
            console.error('Google Maps API failed to load');
            // Create a div to show the error
            const errorDiv = document.createElement('div');
            errorDiv.style.background = '#ffebee';
            errorDiv.style.color = '#d32f2f';
            errorDiv.style.padding = '15px';
            errorDiv.style.borderRadius = '5px';
            errorDiv.style.margin = '10px 0';
            errorDiv.style.textAlign = 'center';
            errorDiv.innerHTML = '<h3>Maps API Error</h3><p>The Google Maps API failed to load. This might be due to an invalid API key. Check the console for more details.</p>';
            
            // Insert at top of body
            document.body.insertBefore(errorDiv, document.body.firstChild);
        }
    </script>
    <!-- Google Maps API script with placeholder API key that will be replaced by the server -->
    <script async
        src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places&callback=initGoogleMapsAPI"
        onerror="handleMapsApiError()">
    </script>
    <!-- Add Google Maps Web Components scripts -->
    <script type="module">
        import { MapElement } from "https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places&v=beta&components=map"
        import { PlaceDetailsElement } from "https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places&v=beta&components=place_details"
        import { AdvancedMarkerElement } from "https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places&v=beta&components=advanced_marker"
    </script>
    <script>
        // Configure marked.js
        document.addEventListener('DOMContentLoaded', function() {
            // Test if marked is available
            if (typeof marked === 'undefined') {
                console.error('Marked.js not loaded properly');
                return;
            }
            
            // Configure marked
            marked.setOptions({
                breaks: true,
                gfm: true,
                headerIds: false,
                mangle: false,
                sanitize: false,
                smartLists: true,
                smartypants: true,
                xhtml: false
            });
            
            console.log('Marked.js configured successfully');
            
            // Test parsing
            const testMd = "**Bold** and *italic* with [link](https://example.com) and\n* List item 1\n* List item 2";
            console.log('Test markdown:', testMd);
            console.log('Parsed result:', marked.parse(testMd));
        });
    </script>
    <style>
        :root {
            --primary-color: #6c5ce7;
            --primary-dark: #5541d7;
            --primary-light: #a29bfe;
            --secondary-color: #00cec9;
            --accent-color: #fd79a8;
            --text-primary: #2d3436;
            --text-secondary: #636e72;
            --bg-color: #f9fafe;
            --card-bg: #ffffff;
            --user-msg-bg: #e4f0ff;
            --agent-msg-bg: #f5f7ff;
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 24px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            line-height: 1.6;
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        h1 {
            font-weight: 700;
            margin-bottom: 1.5rem;
            text-align: center;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: 2.5rem;
            letter-spacing: -0.5px;
        }

        #chat-container {
            flex: 1;
            background-color: var(--card-bg);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            overflow-y: auto;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            height: 60vh;
            scrollbar-width: thin;
            transition: var(--transition);
        }

        #chat-container::-webkit-scrollbar {
            width: 6px;
        }

        #chat-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        #chat-container::-webkit-scrollbar-thumb {
            background: var(--primary-light);
            border-radius: 10px;
        }

        .message {
            margin-bottom: 1rem;
            padding: 1rem 1.2rem;
            border-radius: var(--radius-sm);
            animation: fadeIn 0.3s ease-out;
            box-shadow: var(--shadow-sm);
            max-width: 80%;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message a {
            color: var(--primary-color);
            text-decoration: none;
            word-break: break-all;
            font-weight: 500;
            transition: var(--transition);
        }

        .message a:hover {
            color: var(--primary-dark);
            text-decoration: underline;
        }

        .user-message {
            background-color: var(--user-msg-bg);
            color: var(--text-primary);
            margin-left: auto;
            border-radius: var(--radius-sm) 0 var(--radius-sm) var(--radius-sm);
            border-right: 4px solid var(--primary-color);
            font-weight: 500;
        }

        .agent-message {
            background-color: var(--agent-msg-bg);
            color: var(--text-primary);
            margin-right: auto;
            border-radius: 0 var(--radius-sm) var(--radius-sm) var(--radius-sm);
            border-left: 4px solid var(--secondary-color);
        }

        .streaming:after {
            content: '...';
            display: inline-block;
            width: 1em;
            animation: streamingDots 1.5s infinite;
            color: var(--primary-color);
            font-weight: bold;
        }

        @keyframes streamingDots {
            0% { content: '.'; }
            33% { content: '..'; }
            66% { content: '...'; }
        }

        .system-message {
            color: var(--text-secondary);
            font-style: italic;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-sm);
            margin: 0.8rem auto;
            max-width: 90%;
            font-size: 0.9rem;
            box-shadow: var(--shadow-sm);
            border-left: 2px solid var(--accent-color);
            border-right: 2px solid var(--accent-color);
        }

        .debugging {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            background-color: rgba(0, 0, 0, 0.03);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--radius-sm);
            padding: 0.5rem;
            margin-top: 0.5rem;
            overflow-x: auto;
            max-height: 150px;
            display: none;
        }

        #input-container {
            display: flex;
            gap: 0.8rem;
            position: relative;
            margin-bottom: 1rem;
        }

        #message-input {
            flex-grow: 1;
            padding: 1rem 1.2rem;
            border: none;
            border-radius: var(--radius-lg);
            background-color: var(--card-bg);
            box-shadow: var(--shadow-sm);
            font-family: 'Poppins', sans-serif;
            font-size: 1rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        #message-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--primary-light);
        }

        button {
            padding: 0.8rem 1.5rem;
            background: linear-gradient(45deg, var(--primary-color), var(--primary-dark));
            color: white;
            border: none;
            border-radius: var(--radius-lg);
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: linear-gradient(45deg, #b2b2b2, #d3d3d3);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #session-container {
            margin-bottom: 2rem;
            text-align: center;
        }

        .hidden {
            display: none;
        }

        #settings-container {
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: flex-end;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9rem;
            color: var(--text-secondary);
            user-select: none;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin: 0 0.5rem;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        #location-status {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-right: auto;
            background-color: var(--card-bg);
            padding: 0.5rem 0.8rem;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-sm);
        }

        .location-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            transition: var(--transition);
        }

        .location-on {
            background-color: #00b894;
            box-shadow: 0 0 8px rgba(0, 184, 148, 0.5);
        }

        .location-off {
            background-color: #ff7675;
            box-shadow: 0 0 8px rgba(255, 118, 117, 0.5);
        }

        .location-pending {
            background-color: #fdcb6e;
            box-shadow: 0 0 8px rgba(253, 203, 110, 0.5);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(0.95); opacity: 0.7; }
            50% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(0.95); opacity: 0.7; }
        }

        #create-session-btn {
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: var(--radius-md);
            margin: 2rem auto;
            display: block;
        }

        .message ul, .message ol {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
        }

        .message li {
            margin-bottom: 0.3rem;
        }

        .message p {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        #request-location-btn {
            font-size: 0.8rem;
            padding: 0.4rem 0.8rem;
            margin-left: 0.5rem;
        }

        #chat-interface {
            display: flex;
            flex-direction: column;
            height: 85vh;
        }

        /* Dark mode support - add a toggle button to your HTML */
        .dark-mode {
            --bg-color: #1a1c2a;
            --card-bg: #282a36;
            --text-primary: #f8f8f2;
            --text-secondary: #d3d3d3;
            --user-msg-bg: #483d8b;
            --agent-msg-bg: #2c2c44;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            
            .message {
                max-width: 90%;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            #settings-container {
                flex-direction: column;
                align-items: flex-start;
            }
            
            #location-status {
                margin-right: 0;
                margin-bottom: 0.5rem;
                width: 100%;
            }
        }
        
        /* Map modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.3s;
        }
        
        .modal.show {
            display: block;
        }
        
        .modal-content {
            background-color: var(--card-bg);
            margin: 5% auto;
            border-radius: var(--radius-md);
            width: 80%;
            max-width: 900px;
            box-shadow: var(--shadow-md);
            animation: slideIn 0.4s;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
            color: var(--primary-color);
        }
        
        .close-modal {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition);
        }
        
        .close-modal:hover {
            color: var(--primary-color);
        }
        
        .modal-body {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        #place-info {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        #map-container {
            width: 100%;
            height: 400px;
            border-radius: var(--radius-sm);
            overflow: hidden;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        #place-info {
            margin-bottom: 1rem;
        }
        
        #place-address {
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        #place-rating {
            margin-bottom: 0.5rem;
            color: var(--primary-color);
        }
        
        #place-website {
            margin-bottom: 0.5rem;
        }
        
        #place-website a {
            color: var(--primary-color);
            text-decoration: none;
        }
        
        #place-website a:hover {
            text-decoration: underline;
        }
        
        #place-phone {
            color: var(--text-secondary);
        }
        
        .hidden {
            display: none;
        }
    </style>
    
    <!-- Additional styles for the new session button -->
    <style>
        .small-button {
            font-size: 0.8rem;
            padding: 0.4rem 0.8rem;
            border-radius: var(--radius-sm);
            background: linear-gradient(45deg, var(--secondary-color), var(--primary-light));
            margin-left: 0.5rem;
        }
    </style>
</head>
<body>
    <h1>Taipei travel guide built by Google ADK</h1>
    <div id="session-container">
        <button onclick="createSession()" id="create-session-btn">Create Session</button>
    </div>
    <div id="chat-interface" class="hidden">
        <div id="settings-container">
            <div id="location-status">
                <span class="location-indicator location-pending"></span>
                <span id="location-text">Requesting location...</span>
                <button id="request-location-btn" class="hidden" onclick="requestLocation()">Enable Location</button>
            </div>
            <label class="toggle-label">
                <span>Use Streaming</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="streaming-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <label class="toggle-label">
                <span>Show Debug Info</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="debug-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </label>
            <button onclick="createNewSession()" id="new-session-btn" class="small-button">New Session</button>
        </div>
        <div id="chat-container"></div>
        <div id="input-container">
            <input type="text" id="message-input" placeholder="Type your message...">
            <button onclick="sendMessage()" id="send-button">Send</button>
        </div>
    </div>

    <script>
        // Use our own server as the API URL
        const API_URL = window.location.origin;
        const APP_NAME = 'deep_tAIpei';
        const USER_ID = 'u_123';
        let SESSION_ID = generateSessionId();
        let sessionCreated = false;
        let activeResponseId = null; // Track the current response message for streaming

        // Generate a random session ID
        function generateSessionId() {
            // Generate a random string with timestamp to ensure uniqueness
            const timestamp = new Date().getTime();
            const random = Math.random().toString(36).substring(2, 15);
            return `s_${timestamp}_${random}`;
        }

        // Save session ID to local storage
        function saveSessionId(sessionId) {
            localStorage.setItem('taipeiGuideSessionId', sessionId);
        }

        // Load session ID from local storage
        function loadSessionId() {
            const savedId = localStorage.getItem('taipeiGuideSessionId');
            return savedId || generateSessionId();
        }

        // Initialize from local storage if available
        document.addEventListener('DOMContentLoaded', function() {
            SESSION_ID = loadSessionId();
            
            // Show current session ID in a debug message if debug is enabled
            const debugToggle = document.getElementById('debug-toggle');
            if (debugToggle && debugToggle.checked) {
                console.log(`Current session ID: ${SESSION_ID}`);
            }
        });

        // Create a brand new session (can be called anytime)
        function createNewSession() {
            // Generate a new session ID
            SESSION_ID = generateSessionId();
            saveSessionId(SESSION_ID);
            
            // Reset the UI
            const chatContainer = document.getElementById('chat-container');
            if (chatContainer) {
                chatContainer.innerHTML = '';
            }
            
            // Call createSession to establish a new session
            sessionCreated = false;
            createSession();
        }

        // Location tracking
        let userLocation = null;
        let locationStatus = 'pending'; // 'pending', 'granted', 'denied', 'unsupported'

        function updateLocationStatus(status, message) {
            const indicator = document.querySelector('.location-indicator');
            const statusText = document.getElementById('location-text');
            const requestBtn = document.getElementById('request-location-btn');
            
            locationStatus = status;
            
            // Update indicator
            indicator.className = 'location-indicator';
            indicator.classList.add(`location-${status === 'granted' ? 'on' : (status === 'pending' ? 'pending' : 'off')}`);
            
            // Update text
            statusText.textContent = message;
            
            // Show/hide request button
            if (status === 'denied') {
                requestBtn.classList.remove('hidden');
            } else {
                requestBtn.classList.add('hidden');
            }
        }

        function requestLocation() {
            updateLocationStatus('pending', 'Requesting location...');
            
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    handleLocationSuccess,
                    handleLocationError
                );
            } else {
                updateLocationStatus('unsupported', 'Geolocation not supported by browser');
            }
        }

        function handleLocationSuccess(position) {
            userLocation = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: new Date().toISOString()
            };
            
            updateLocationStatus('granted', `Location available (${userLocation.lat.toFixed(2)}, ${userLocation.lng.toFixed(2)})`);
            
            // Send location to server
            storeLocation();
        }

        function handleLocationError(error) {
            console.error('Geolocation error:', error);
            
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    updateLocationStatus('denied', 'Location permission denied');
                    break;
                case error.POSITION_UNAVAILABLE:
                    updateLocationStatus('denied', 'Location information unavailable');
                    break;
                case error.TIMEOUT:
                    updateLocationStatus('denied', 'Location request timed out');
                    break;
                default:
                    updateLocationStatus('denied', 'Unknown location error');
            }
        }

        async function storeLocation() {
            if (!userLocation) return;
            
            try {
                const response = await fetch(`${API_URL}/proxy/store_location`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(userLocation)
                });
                
                if (!response.ok) {
                    console.error('Failed to store location on server');
                }
            } catch (error) {
                console.error('Error storing location:', error);
            }
        }

        async function createSession() {
            const createSessionBtn = document.getElementById('create-session-btn');
            if (!createSessionBtn) {
                console.error('Create session button not found');
                return;
            }

            try {
                createSessionBtn.disabled = true;
                addMessage('Creating new session...', 'system');
                
                // Show the current session ID in debug view
                addMessage(`Session ID: ${SESSION_ID}`, 'system');
                
                const response = await fetch(`${API_URL}/proxy/session/${APP_NAME}/${USER_ID}/${SESSION_ID}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        state: {
                            key1: "value1",
                            key2: 42
                        }
                    })
                });
                
                // Save successful session ID to local storage
                saveSessionId(SESSION_ID);
                
                const responseData = await response.json();
                console.log('Session creation response:', responseData);

                // Check if it's a "Session already exists" error, which we'll treat as success
                if (response.status === 400 && responseData.detail && responseData.detail.includes("Session already exists")) {
                    console.log("Session already exists, continuing as normal");
                    
                    // Show chat interface and hide create session button
                    document.getElementById('chat-interface').classList.remove('hidden');
                    document.getElementById('session-container').classList.add('hidden');
                    sessionCreated = true;
                    addMessage('Using existing session. You can now start chatting.', 'system');
                    
                    // Request location as soon as session is created/connected
                    requestLocation();
                    return;
                }

                if (!response.ok) {
                    throw new Error(`Failed to create session: ${response.status}`);
                }
                
                // Show chat interface and hide create session button
                document.getElementById('chat-interface').classList.remove('hidden');
                document.getElementById('session-container').classList.add('hidden');
                sessionCreated = true;
                addMessage('Session created successfully! You can now start chatting.', 'system');
                
                // Request location as soon as session is created
                requestLocation();
            } catch (error) {
                console.error('Error creating session:', error);
                addMessage(`Error: ${error.message}. Make sure you started the ADK server in the correct directory.`, 'system');
                if (createSessionBtn) {
                    createSessionBtn.disabled = false;
                }
            }
        }

        function addMessage(text, type, responseId = null) {
            const chatContainer = document.getElementById('chat-container');
            
            // Debug the input text
            if (type === 'agent') {
                console.log('Agent message to parse:', text);
            }
            
            // If this is a streaming update and we have a response ID, find the existing message
            if (type === 'agent' && responseId && responseId === activeResponseId) {
                const existingMsg = document.getElementById(`response-${responseId}`);
                if (existingMsg) {
                    // Only parse markdown for agent messages
                    existingMsg.innerHTML = type === 'user' ? text : processText(text);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    return existingMsg;
                }
            }
            
            // Otherwise create a new message
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            // Only parse markdown for agent messages
            messageDiv.innerHTML = type === 'user' ? text : processText(text);
            
            // If this is an agent response with an ID, set it
            if (type === 'agent' && responseId) {
                messageDiv.id = `response-${responseId}`;
                activeResponseId = responseId;
            }
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            return messageDiv;
        }
        
        // Helper function to process text with markdown and fix URLs
        function processText(text) {
            if (!text) return '';
            
            console.log('Processing text with markdown:', text);
            
            try {
                // Pre-process the text to ensure proper markdown format
                // Make sure numbered lists have a space after the period
                let processedText = text.replace(/^(\d+)\.(\S)/gm, '$1. $2');
                
                // Make sure bullet points have a space after them
                processedText = processedText.replace(/^[*-](\S)/gm, '* $1');
                
                console.log('Pre-processed text:', processedText);
                
                // Process with marked library
                const markedOutput = marked.parse(processedText);
                console.log('Marked output:', markedOutput);
                
                // Sanitize the output with DOMPurify to prevent XSS
                const sanitized = typeof DOMPurify !== 'undefined' ? 
                    DOMPurify.sanitize(markedOutput) : markedOutput;
                
                return sanitized;
            } catch (e) {
                console.error("Error parsing markdown:", e);
                // Fallback to basic processing if marked fails
                return simpleMarkdown(text);
            }
        }
        
        // Simple markdown processor as fallback
        function simpleMarkdown(text) {
            if (!text) return '';
            
            console.log('Using simple markdown processor');
            
            // Convert line breaks to <br>
            let html = text.replace(/\n/g, '<br>');
            
            // Bold text
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Italic text
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Numbered lists
            if (html.match(/^\d+\.\s+.+/gm)) {
                let lines = html.split('<br>');
                let inList = false;
                
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].match(/^\d+\.\s+.+/)) {
                        if (!inList) {
                            lines[i] = '<ol><li>' + lines[i].replace(/^\d+\.\s+/, '') + '</li>';
                            inList = true;
                        } else {
                            lines[i] = '<li>' + lines[i].replace(/^\d+\.\s+/, '') + '</li>';
                        }
                        
                        // If next line is not a list item or this is the last line
                        if (i === lines.length - 1 || !lines[i+1].match(/^\d+\.\s+.+/)) {
                            lines[i] += '</ol>';
                            inList = false;
                        }
                    }
                }
                
                html = lines.join('<br>');
            }
            
            // Bullet lists
            if (html.match(/^[\*-]\s+.+/gm)) {
                let lines = html.split('<br>');
                let inList = false;
                
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].match(/^[\*-]\s+.+/)) {
                        if (!inList) {
                            lines[i] = '<ul><li>' + lines[i].replace(/^[\*-]\s+/, '') + '</li>';
                            inList = true;
                        } else {
                            lines[i] = '<li>' + lines[i].replace(/^[\*-]\s+/, '') + '</li>';
                        }
                        
                        // If next line is not a list item or this is the last line
                        if (i === lines.length - 1 || !lines[i+1].match(/^[\*-]\s+.+/)) {
                            lines[i] += '</ul>';
                            inList = false;
                        }
                    }
                }
                
                html = lines.join('<br>');
            }
            
            // URLs
            html = html.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
            
            return html;
        }

        function addDebugInfo(messageElement, data) {
            // Check if we should show debug info
            const showDebug = document.getElementById('debug-toggle').checked;
            
            // Create debug element
            const debugDiv = document.createElement('div');
            debugDiv.className = 'debugging';
            debugDiv.style.display = showDebug ? 'block' : 'none';
            
            // Format the debug content
            let debugContent;
            try {
                if (typeof data === 'string') {
                    debugContent = data;
                } else {
                    debugContent = JSON.stringify(data, null, 2);
                }
            } catch (e) {
                debugContent = String(data);
            }
            
            debugDiv.textContent = debugContent;
            messageElement.appendChild(debugDiv);
            
            // Update toggle listener
            document.getElementById('debug-toggle').addEventListener('change', (e) => {
                const debugElements = document.querySelectorAll('.debugging');
                debugElements.forEach(el => {
                    el.style.display = e.target.checked ? 'block' : 'none';
                });
            });
        }

        async function sendMessage() {
            if (!sessionCreated) {
                addMessage('Please create a session first!', 'system');
                return;
            }

            const input = document.getElementById('message-input');
            const sendButton = document.getElementById('send-button');
            const message = input.value.trim();
            const useStreaming = document.getElementById('streaming-toggle').checked;
            
            if (!message) return;
            
            // Add user message to chat
            addMessage(message, 'user');
            input.value = '';
            sendButton.disabled = true;

            // Reset active response tracking
            activeResponseId = null;
            
            try {
                if (useStreaming) {
                    // Step 1: Prepare the SSE connection by sending a POST request
                    const prepareResponse = await fetch(`${API_URL}/proxy/prepare_sse`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            app_name: APP_NAME,
                            user_id: USER_ID,
                            session_id: SESSION_ID,
                            new_message: {
                                role: "user",
                                parts: [{
                                    text: message
                                }]
                            }
                        })
                    });
                    
                    if (!prepareResponse.ok) {
                        throw new Error(`Failed to prepare streaming: ${prepareResponse.status}`);
                    }
                    
                    const prepareData = await prepareResponse.json();
                    const requestId = prepareData.request_id;
                    
                    if (!requestId) {
                        throw new Error("No request ID received for streaming");
                    }
                    
                    // Step 2: Connect to the SSE endpoint with the request ID
                    const eventSource = new EventSource(`${API_URL}/proxy/sse_connect/${requestId}`);
                    
                    let messageElement = null;
                    let finalText = '';
                    
                    eventSource.onmessage = async (event) => {
                        // Skip empty events
                        if (!event.data.trim()) return;
                        
                        // Get chat container here to ensure it's in scope
                        const chatContainer = document.getElementById('chat-container');
                        if (!chatContainer) {
                            console.error('Chat container not found');
                            return;
                        }
                        
                        try {
                            // Process each event
                            console.log("SSE Event:", event);
                            
                            const data = JSON.parse(event.data);
                            
                            // Process tool calls, function responses, and text responses
                            if (data.content && data.content.parts) {
                                for (const part of data.content.parts) {
                                    // Function call (showing what the agent is doing)
                                    if (part.functionCall) {
                                        const functionName = part.functionCall.name;
                                        const args = part.functionCall.args;
                                        finalText = `Fetching data using ${functionName}...`;
                                        
                                        if (!messageElement) {
                                            messageElement = addMessage(finalText, 'agent', data.id);
                                            addDebugInfo(messageElement, data);
                                        } else {
                                            messageElement.textContent = finalText;
                                            addDebugInfo(messageElement, data);
                                        }
                                    }
                                    
                                    // Function response
                                    if (part.functionResponse) {
                                        const functionName = part.functionResponse.name;
                                        const response = part.functionResponse.response;
                                        
                                        // Check if this is a place details response
                                        if (functionName === 'show_place_details') {
                                            // Use a self-executing async function to use await
                                            (async () => {
                                                if (await handlePlaceDetailsResponse(response)) {
                                                    // If handled, update the message to indicate a map is being shown
                                                    finalText = `Showing ${response.name || 'place'} on a map`;
                                                    
                                                    if (!messageElement) {
                                                        messageElement = addMessage(finalText, 'agent', data.id);
                                                    } else {
                                                        messageElement.innerHTML = processText(finalText);
                                                    }
                                                }
                                            })();
                                            continue;
                                        }
                                        
                                        if (response.report) {
                                            finalText = `Got data from ${functionName}: ${response.report}`;
                                        } else {
                                            finalText = `Function ${functionName} completed.`;
                                        }
                                        
                                        if (!messageElement) {
                                            messageElement = addMessage(finalText, 'agent', data.id);
                                            addDebugInfo(messageElement, data);
                                        } else {
                                            messageElement.textContent = finalText;
                                            addDebugInfo(messageElement, data);
                                        }
                                    }
                                    
                                    // Text response (final output)
                                    if (part.text) {
                                        // Check if this is a complete message
                                        const isCompleteMessage = 
                                            part.text.length > 50 || // Longer messages are likely complete
                                            part.text.includes("Function") && part.text.includes("completed") ||
                                            part.text.trim().startsWith("Okay,") ||
                                            part.text.trim().startsWith("Here are") ||
                                            part.text.trim().startsWith("Sure,");
                                            
                                        if (isCompleteMessage) {
                                            // This is a complete message - replace existing content
                                            finalText = part.text;
                                        } else if (!finalText.includes(part.text)) {
                                            // This is a fragment - append if not already included
                                            finalText += part.text;
                                        }
                                        
                                        if (!messageElement) {
                                            // Create the initial message element without markdown
                                            messageElement = document.createElement('div');
                                            messageElement.className = `message agent-message streaming`;
                                            messageElement.textContent = finalText;
                                            
                                            if (data.id) {
                                                messageElement.id = `response-${data.id}`;
                                                activeResponseId = data.id;
                                            }
                                            
                                            chatContainer.appendChild(messageElement);
                                            addDebugInfo(messageElement, data);
                                        } else {
                                            // Update the text content first
                                            messageElement.textContent = finalText;
                                            
                                            // Only apply markdown on the final message or after a delay
                                            clearTimeout(messageElement.pendingMarkdown);
                                            
                                            if (isCompleteMessage) {
                                                // Apply markdown immediately for complete messages
                                                messageElement.classList.remove('streaming');
                                                messageElement.innerHTML = processText(finalText);
                                                console.log('Applied markdown to complete message');
                                            } else {
                                                // For fragments, wait a bit to collect more text
                                                messageElement.pendingMarkdown = setTimeout(() => {
                                                    messageElement.classList.remove('streaming');
                                                    messageElement.innerHTML = processText(finalText);
                                                    console.log('Applied markdown to accumulated text');
                                                }, 500);
                                            }
                                            
                                            addDebugInfo(messageElement, data);
                                        }
                                        
                                        chatContainer.scrollTop = chatContainer.scrollHeight;
                                    }
                                }
                            }
                        } catch (e) {
                            console.error("Error processing SSE event:", e);
                            // Try to show the raw event data if parsing fails
                            if (!messageElement) {
                                messageElement = addMessage(`Processing response...`, 'agent');
                                addDebugInfo(messageElement, event.data);
                            }
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        console.error("SSE Error:", error);
                        eventSource.close();
                        
                        // Show error if no messages have been displayed
                        if (!messageElement) {
                            addMessage("Error getting response from agent", 'system');
                        } else {
                            // Make sure we remove the streaming indicator if there's an error
                            messageElement.classList.remove('streaming');
                        }
                        
                        sendButton.disabled = false;
                    };
                    
                    // Close the event source after a minute (should be done much earlier)
                    setTimeout(() => {
                        if (eventSource.readyState !== 2) { // Not closed
                            eventSource.close();
                            sendButton.disabled = false;
                        }
                    }, 60000);
                } else {
                    // Use regular endpoint for non-streaming
                    const response = await fetch(`${API_URL}/proxy/run`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            app_name: APP_NAME,
                            user_id: USER_ID,
                            session_id: SESSION_ID,
                            new_message: {
                                role: "user",
                                parts: [{
                                    text: message
                                }]
                            }
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API error: ${response.status} ${errorText}`);
                    }

                    const data = await response.json();
                    console.log("API Response:", data);
                    
                    if (data && data.length > 0) {
                        // Looking for model responses by checking each event
                        for (const event of data) {
                            // Check if this is a model's text response
                            if (event.content && event.content.parts) {
                                for (const part of event.content.parts) {
                                    // Check for place details response first
                                    if (part.functionResponse && 
                                        part.functionResponse.name === 'show_place_details') {
                                        const response = part.functionResponse.response;
                                        
                                        // Use async/await with an IIFE
                                        (async () => {
                                            if (await handlePlaceDetailsResponse(response)) {
                                                // Add a message indicating place is showing on map
                                                const msgElement = addMessage(
                                                    `Showing ${response.name || 'place'} on a map`, 
                                                    'agent'
                                                );
                                                addDebugInfo(msgElement, event);
                                            }
                                        })();
                                        continue;
                                    }
                                    
                                    // Regular text response
                                    if (part.text) {
                                        const msgElement = addMessage(part.text, 'agent');
                                        addDebugInfo(msgElement, event);
                                        // Break after finding the first text response
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        addMessage("No response from agent", 'system');
                    }
                    
                    sendButton.disabled = false;
                }
            } catch (error) {
                console.error('Error sending message:', error);
                addMessage(`Error: ${error.message}`, 'system');
                sendButton.disabled = false;
            }
        }

        // Allow sending message with Enter key
        document.getElementById('message-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !document.getElementById('send-button').disabled) {
                sendMessage();
            }
        });

        // Toggle event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize any toggles that need immediate setup
            document.getElementById('debug-toggle').addEventListener('change', (e) => {
                const debugElements = document.querySelectorAll('.debugging');
                debugElements.forEach(el => {
                    el.style.display = e.target.checked ? 'block' : 'none';
                });
            });
            
            // Initialize map modal events
            initMapModal();
        });
        
        // Map and place details handling
        let map = null;
        let placeMarker = null;
        let placesService = null;
        
        function initMapModal() {
            // Set up modal close button
            const closeButton = document.querySelector('.close-modal');
            if (closeButton) {
                closeButton.addEventListener('click', closeMapModal);
            }
            
            // Close modal when clicking outside
            window.addEventListener('click', (e) => {
                const modal = document.getElementById('map-modal');
                if (e.target === modal) {
                    closeMapModal();
                }
            });
            
            // Close with escape key
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeMapModal();
                }
            });
        }
        
        function showMapModal() {
            const modal = document.getElementById('map-modal');
            modal.classList.remove('hidden');
            modal.classList.add('show');
        }
        
        function closeMapModal() {
            const modal = document.getElementById('map-modal');
            modal.classList.remove('show');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }
        
        async function initializeMap(placeId, lat, lng) {
            // Check if map already initialized
            const mapContainer = document.getElementById('map');
            
            // Check if Google Maps API is loaded
            if (typeof google === 'undefined' || !window.mapsApiLoaded) {
                console.error('Google Maps API not loaded properly');
                
                // Show error message in map container
                mapContainer.innerHTML = '<div style="padding: 20px; color: #d63031; text-align: center;">' +
                    '<p>Unable to load Google Maps.</p>' +
                    '<p>Please check your internet connection and API key.</p>' +
                    '<p><strong>Error:</strong> Maps API is not available.</p></div>';
                
                // Show the modal anyway so user can see error
                showMapModal();
                return false;
            }
            
            try {
                // Show modal first
                showMapModal();
                
                // Initialize map if needed
                if (!map) {
                    // Center coordinates (default to Taipei)
                    const center = { lat: lat || 25.033, lng: lng || 121.565 };
                    
                    // Create the map
                    map = new google.maps.Map(mapContainer, {
                        center: center,
                        zoom: 16,
                        mapTypeControl: false,
                        fullscreenControl: true,
                        streetViewControl: true,
                        zoomControl: true
                    });
                    
                    // Initialize the Places service
                    placesService = new google.maps.places.PlacesService(map);
                }
                
                // If we have a place ID, get details and display them
                if (placeId) {
                    console.log('Getting details for Place ID:', placeId);
                    
                    // Request place details
                    const request = {
                        placeId: placeId,
                        fields: ['name', 'formatted_address', 'geometry', 'rating', 
                                'website', 'formatted_phone_number', 'photos', 'types',
                                'opening_hours', 'price_level', 'user_ratings_total']
                    };
                    
                    // Get place details
                    placesService.getDetails(request, (place, status) => {
                        if (status === google.maps.places.PlacesServiceStatus.OK && place) {
                            // Display place details
                            displayPlaceInfo(place);
                            
                            // Center map on place location
                            map.setCenter(place.geometry.location);
                            
                            // Add a marker for the place
                            if (placeMarker) {
                                placeMarker.setPosition(place.geometry.location);
                            } else {
                                placeMarker = new google.maps.Marker({
                                    position: place.geometry.location,
                                    map: map,
                                    animation: google.maps.Animation.DROP
                                });
                            }
                        } else {
                            console.error('Error fetching place details:', status);
                            document.getElementById('place-address').textContent = 'Error fetching place details';
                        }
                    });
                }
                // Or if we just have coordinates, display them
                else if (lat && lng) {
                    const latLng = new google.maps.LatLng(lat, lng);
                    map.setCenter(latLng);
                    
                    // Add a marker
                    if (placeMarker) {
                        placeMarker.setPosition(latLng);
                    } else {
                        placeMarker = new google.maps.Marker({
                            position: latLng,
                            map: map,
                            animation: google.maps.Animation.DROP
                        });
                    }
                    
                    // Try to get place info from reverse geocoding
                    const geocoder = new google.maps.Geocoder();
                    geocoder.geocode({ location: latLng }, (results, status) => {
                        if (status === "OK" && results[0]) {
                            document.getElementById('place-address').textContent = results[0].formatted_address;
                        } else {
                            document.getElementById('place-address').textContent = `Location: ${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                        }
                    });
                }
                
                return true;
            } catch (e) {
                console.error('Error initializing map:', e);
                
                // Show error message in map container
                mapContainer.innerHTML = '<div style="padding: 20px; color: #d63031; text-align: center;">' +
                    '<p>Error initializing map: ' + e.message + '</p>' +
                    '<p>Please check the console for more details.</p></div>';
                
                return false;
            }
        }
        
        function displayPlaceInfo(place) {
            // Set place name
            document.getElementById('place-name').textContent = place.name || 'Place Details';
            
            // Set address
            document.getElementById('place-address').textContent = place.formatted_address || '';
            
            // Set rating with stars
            let ratingHTML = '';
            if (place.rating) {
                ratingHTML = `Rating: ${place.rating} / 5 `;
                const fullStars = Math.floor(place.rating);
                const halfStar = place.rating % 1 >= 0.5;
                
                for (let i = 0; i < fullStars; i++) {
                    ratingHTML += '★';
                }
                if (halfStar) {
                    ratingHTML += '½';
                }
                
                // Add total ratings count if available
                if (place.user_ratings_total) {
                    ratingHTML += ` (${place.user_ratings_total} reviews)`;
                }
            }
            document.getElementById('place-rating').innerHTML = ratingHTML;
            
            // Set website
            if (place.website) {
                document.getElementById('place-website').innerHTML = 
                    `<a href="${place.website}" target="_blank" rel="noopener">Visit Website</a>`;
            } else {
                document.getElementById('place-website').innerHTML = '';
            }
            
            // Set phone
            if (place.formatted_phone_number) {
                document.getElementById('place-phone').textContent = `Phone: ${place.formatted_phone_number}`;
            } else {
                document.getElementById('place-phone').textContent = '';
            }
        }
        
        async function displayPlaceDetails(placeData) {
            console.log('Displaying place details:', placeData);
            
            if (!placeData) {
                console.error('Invalid place data');
                return;
            }
            
            // Update modal title
            document.getElementById('place-name').textContent = placeData.name || 'Place Details';
            
            try {
                // If we have a place ID, use that for better details
                if (placeData.place_id) {
                    console.log('Displaying place with ID:', placeData.place_id);
                    await initializeMap(placeData.place_id, null, null);
                }
                // Otherwise fall back to coordinates
                else if (placeData.location && placeData.location.lat && placeData.location.lng) {
                    console.log('Displaying place with coordinates:', placeData.location);
                    
                    // Display the location info 
                    document.getElementById('place-address').textContent = placeData.address || '';
                    
                    // Set rating
                    let ratingHTML = '';
                    if (placeData.rating) {
                        ratingHTML = `Rating: ${placeData.rating} / 5 `;
                        const fullStars = Math.floor(placeData.rating);
                        const halfStar = placeData.rating % 1 >= 0.5;
                        
                        for (let i = 0; i < fullStars; i++) {
                            ratingHTML += '★';
                        }
                        if (halfStar) {
                            ratingHTML += '½';
                        }
                    }
                    document.getElementById('place-rating').innerHTML = ratingHTML;
                    
                    // Set website
                    if (placeData.website) {
                        document.getElementById('place-website').innerHTML = 
                            `<a href="${placeData.website}" target="_blank" rel="noopener">Visit Website</a>`;
                    } else {
                        document.getElementById('place-website').innerHTML = '';
                    }
                    
                    // Set phone
                    if (placeData.phone) {
                        document.getElementById('place-phone').textContent = `Phone: ${placeData.phone}`;
                    } else {
                        document.getElementById('place-phone').textContent = '';
                    }
                    
                    await initializeMap(null, placeData.location.lat, placeData.location.lng);
                }
                else {
                    console.error('No valid place ID or coordinates found in place data');
                    showMapModal(); // Show modal anyway with an error
                    const mapContainer = document.getElementById('map-container');
                    mapContainer.innerHTML = '<div style="padding: 20px; color: #d63031; text-align: center;">' +
                        '<p>Unable to display place: no valid location data.</p></div>';
                }
            } catch (error) {
                console.error('Error displaying place details:', error);
                showMapModal(); // Show modal anyway with an error
                const mapContainer = document.getElementById('map-container');
                mapContainer.innerHTML = '<div style="padding: 20px; color: #d63031; text-align: center;">' +
                    '<p>Error displaying place details: ' + error.message + '</p></div>';
            }
        }
        
        // Function to handle place details response from the AI
        async function handlePlaceDetailsResponse(response) {
            console.log('Received place details response:', response);
            
            if (!response) {
                console.error('Empty response received in handlePlaceDetailsResponse');
                return false;
            }
            
            if (response.status !== 'success') {
                console.error('Place details response status:', response.status);
                return false;
            }
            
            if (!response.ui_action) {
                console.error('Missing ui_action flag in place details response');
                return false;
            }
            
            if (response.status === 'success' && 
                response.ui_action === 'show_map') {
                
                // Display place details on map
                try {
                    await displayPlaceDetails(response);
                    return true;
                } catch (e) {
                    console.error('Error displaying place details:', e);
                    return false;
                }
            }
            
            console.log('Place details response did not meet criteria for map display');
            return false;
        }
    </script>

    <!-- Add map modal container -->
    <div id="map-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="place-name">Place Details</h2>
                <span class="close-modal">&times;</span>
            </div>
            <div class="modal-body">
                <div id="place-info">
                    <!-- Place details will be inserted here -->
                    <div id="place-address"></div>
                    <div id="place-rating"></div>
                    <div id="place-website"></div>
                    <div id="place-phone"></div>
                </div>
                <div id="map-container">
                    <!-- Map will be inserted here -->
                    <div id="map"></div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>